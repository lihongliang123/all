package com.charles.algorithm.sort;

/**
 * Charles Lee original, reprint please indicate the source
 * <p>
 * 排序算法的分类
 * 1, 内部排序法: 将需要处理的所有数据都加载到内部存储器中进行排序
 * 2, 外部排序法: 数据量过大,无法全部加载到内存中,需要借助外部存储进行排序
 * <p>
 * 常见的排序算法分为
 * 1, 内部排序
 * 1.1) 插入排序
 * 1.1.1) 直接插入排序
 * 1.1.2) 希尔排序
 * 1.2) 选择排序
 * 1.2.1) 简单选择排序
 * 1.2.2) 堆排序
 * 1.3) 交换排序
 * 1.3.1) 冒泡排序
 * 1.3.2) 快速排序
 * 1.4) 归并排序
 * 1.5) 基数排序 (桶排序的扩展)
 * 2, 外部排序, 使用内存和外存结合
 * <p>
 * 时间频度: 一个算法花费的时间与算法中语句的执行次数成正比,哪个算法中语句执行次数越多,它所花费的时间也就越多,
 * 一个算法中的语句执行次数称为语句频度或时间频度, 记为T(n).
 * <p>
 * 常见时间的复杂度
 * 1,常数阶O(1)
 * 2,对数阶O(以2为底n的对数,log2n)
 * 3,线性阶O(n)
 * 4,线性对数阶O(nlog2n)
 * 5,平方阶O(n * n)
 * 6,立方阶O(n * n * n)
 * 7,K次方阶O(n的k次方)
 * 8,指数阶O(2的n次方)
 * 9,n的n次阶O(n!)
 * <p>
 * 平均时间复杂度和最坏时间复杂度
 * 平均时间复杂度: 所有可能的输入实例均以等概率出现的情况下,该算法的运行时间
 * 最坏时间复杂度: 一般讨论的是最坏情况下的时间复杂度,这样做的原因是最坏情况下的时间复杂度是算法在任何输入实例上的运行时间的界限,这就保证了算法的运行时间不会比最坏的情况更长
 * <p>
 * 算法的空间复杂度
 * 1, 算法的空间复杂度定义为该算法所耗费的存储空间,他也是问题规模n的函数
 * 2, 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关,他随着n的增加而增加,当n较大时,将占用较多的存储单元
 * 3, 做算法分析的时候,主要讨论的是时间复杂度问题,从用户体验上来看,更看重程序的执行速度,一些缓存产品(如: redis), 本质上就是空间换时间。
 * <p>
 * <p>
 * 相关术语
 * 稳定:   如果a原本在b前,而a = b,排序之后a依然在前面
 * 不稳定: 如果a原本在b前,而a = b,排序之后a可能会出现在b的后面
 *
 *
 * @author CharlesLee
 */
public interface SortAlgorithm<E> {

    void sort(E e);

    /**
     * 用来演示常数阶的代码
     * <p>
     * 无论代码执行了多少行,只要没有循环等复杂结构,那么这个代码的时间复杂度就都是O(1)
     * 这个代码在执行的时候,它的消耗时间并不会随着某个变量的增长而增加,那么无论这个代码有多长,都是常数阶
     */
    default void demo1() {
        int i = 1;
        int j = 1;
        i++;
        ++j;
        int m = i + j;
    }

    /**
     * 用来演示对数阶的代码
     * <p>
     * 在while循环里面,每次都将i乘以2,i就会距离n越来越近,假设循环x次之后,i就大于2了,那么这个循环也就退出了,也就说2的x次方大于等于n
     * 那么也就是说循环log2n次以后,这个代码结束了,那么这个代码的时间复杂度为 log2n,这个2根据是根据代码来发生变化的
     * 如果 i = i * 3, 那么是 O(log3n)
     */
    default void demo2() {
        // n代表随意一个很大的数字
        int n = 11111;
        int i = 1;
        while (i < n) {
            i = i * 2;
        }
    }

    /**
     * 线性阶
     * <p>
     * 单层的for循环也就是线性阶.
     * 在这段代码里,循环里面的代码会执行n遍,则它消耗的时间是随着n的变化而变化的,因此这类代码可以用O(n)来表示它的时间复杂度
     */
    default void demo3() {
        // n代表随意一个很大的数字
        int n = 11111;
        for (int i = 0; i < n; i++) {
            System.out.println(i);
        }
    }

    /**
     * 线性对数阶
     * <p>
     * 将时间复杂度为 O(log2n)的代码循环n遍,那么它的时间复杂度就是线性对数阶
     */
    default void demo4() {
        // n代表随意一个很大的数字
        int n = 11111;
        for (int i = 0; i < n; i++) {
            int j = 1;
            while (j < n) {
                j *= 2;
            }
        }
    }


    /**
     * 平方阶
     * <p>
     * 说白了就是for中套for, 如果一个循环运行一百次,那么该算法就总共会运行一万次,其时间复杂度为O(n*n)
     * <p>
     * 立方阶,三层for循环嵌套
     * <p>
     * K次方阶段, k次for循环嵌套...
     */
    default void demo5() {
        // n代表随意一个很大的数字
        int n = 100;
        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                count++;
            }
        }
    }


}
